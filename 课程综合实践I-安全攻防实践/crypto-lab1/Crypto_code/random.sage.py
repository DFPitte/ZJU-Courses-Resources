

# This file was *autogenerated* from the file random.sage
from sage.all_cmdline import *   # import sage library

_sage_const_256 = Integer(256); _sage_const_3 = Integer(3); _sage_const_0 = Integer(0); _sage_const_255 = Integer(255); _sage_const_9 = Integer(9); _sage_const_32 = Integer(32); _sage_const_126 = Integer(126); _sage_const_25 = Integer(25); _sage_const_10 = Integer(10)
import random

# 1. 随机生成一个可逆的 3x3 矩阵 MT
def generate_invertible_matrix():
    while True:
        MT = Matrix(Zmod(_sage_const_256 ), _sage_const_3 , _sage_const_3 , [random.randint(_sage_const_0 , _sage_const_255 ) for _ in range(_sage_const_9 )])
        if MT.is_invertible():
            return MT

MT = generate_invertible_matrix()
print(MT)

# 2. 生成一个随机的 flag，并通过 flag 生成矩阵 FT
flag = "AAA{" + "".join(chr(random.randint(_sage_const_32 , _sage_const_126 )) for _ in range(_sage_const_25 ))+"}"
FT = Matrix(Zmod(_sage_const_256 ), _sage_const_3 , _sage_const_10 )
for i in range(_sage_const_3 ):
    for j in range(_sage_const_10 ):
        FT[i, j] = ord(flag[i + j * _sage_const_3 ])
print(flag)
print(FT)

# 3. 计算 RT = MT * FT
RT = MT * FT
print("RT (result of MT * FT):\n", RT)

# 4. 通过已知的 RT 和 MT，求解 FT
MT_inv = MT.inverse()
FT_computed = MT_inv * RT
print(FT_computed)

